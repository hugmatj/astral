<template>
  <div
    class="flex items-center px-1 pt-2 pb-0 bg-white border border-gray-300 rounded-md shadow-sm ring-2 ring-transparent cursor-text focus-within:border-indigo-500 focus-within:ring-indigo-100"
    @click.stop
  >
    <ul class="relative flex flex-wrap items-center w-full">
      <li
        v-for="(tag, i) in mutableTags"
        :key="tag.name"
        class="text-indigo-800 bg-indigo-100 px-2 py-0.5 mx-1 mb-2 rounded-sm text-xs font-semibold tracking-wide flex items-center"
      >
        <span>{{ tag.name }}</span>
        <button
          class="pl-1 cursor-pointer delete-star-tag"
          :aria-label="`Delete tag ${tag.name}`"
          @mousedown.prevent
          @click.stop="deleteTagAtIndex(i)"
        >
          <XIcon class="w-3 h-3 fill-current" />
        </button>
      </li>
      <li class="relative flex-grow mx-1 mb-2 leading-none isolate" style="flex-basis: 82px">
        <input
          ref="input"
          v-model="tagText"
          type="text"
          class="w-full min-w-0 p-0 text-base leading-none bg-transparent border-0 sm:text-sm focus:outline-none focus:border-0 focus:ring-0"
          placeholder="Add a tag..."
          role="combobox"
          :aria-activedescendant="autocompleteUUID"
          autocomplete="off"
          :aria-owns="autocompleteUUID"
          @keydown.,.prevent="addTagFromInput"
          @keydown.delete="deleteLastTag"
          @blur="onBlur"
          @keydown.enter="onEnter"
        />

        <!-- Autocomplete Menu -->
        <AutocompleteMenu
          :id="autocompleteUUID"
          :style="{
            left: inputRect.left + 'px',
            top: inputRect.top + inputRect.height + 'px',
          }"
          :source="autocompleteOptions"
          :search="tagText"
          @select="addTagWithName($event)"
          @show="autocompleteShowing = true"
          @hide="autocompleteShowing = false"
        />
      </li>
    </ul>
  </div>
</template>

<script lang="ts" setup>
import { computed, nextTick, PropType, reactive, ref, unref, watch } from 'vue'
import { useTagsStore } from '@/store/useTagsStore'
import AutocompleteMenu from '@/components/tags-editor/AutocompleteMenu.vue'
import { XIcon } from '@heroicons/vue/solid'
import { TagEditorTag } from '@/types'
import { whenever } from '@vueuse/core'
import { nanoid } from 'nanoid'

const props = defineProps({
  tags: {
    type: Array as PropType<TagEditorTag[]>,
    default: () => [],
  },
  canCreate: {
    type: Boolean,
    default: true,
  },
  placeholder: {
    type: String,
    default: 'Add a tag...',
  },
  autocompleteOptions: {
    type: Array as PropType<string[]>,
    default: () => [],
  },
})

const emit = defineEmits<{
  (e: 'change', value: TagEditorTag[]): void
  (e: 'blur'): void
}>()

const tagsStore = useTagsStore()
const autocompleteUUID = nanoid()
const tagText = ref('')
const input = ref<HTMLInputElement | null>(null)
const mutableTags = ref<TagEditorTag[]>(props.tags.map((tag) => ({ id: tag.id, name: tag.name })))
let inputRect = reactive<Pick<Record<keyof DOMRect, number>, 'top' | 'left' | 'height'>>({
  top: 0,
  left: 0,
  height: 20,
})
const autocompleteShowing = ref(false)

const autocompleteOptions = computed(() => {
  return props.autocompleteOptions.filter((option) => {
    return !mutableTags.value.map((tag) => tag.name).includes(option)
  })
})

whenever(input, () => {
  positionAutocompleteMenu()
})

watch(mutableTags.value, () => {
  setTimeout(() => {
    positionAutocompleteMenu()
  }, 10)
})

const positionAutocompleteMenu = () => {
  if (input.value) {
    const { top, left } = input.value.getBoundingClientRect()
    inputRect.top = top
    inputRect.left = left
  }
}

const tagsHasTag = (tag: string) => {
  return mutableTags.value.map((tag) => tag.name?.toLowerCase()).includes(tag?.toLowerCase())
}

const tagsHaveChanged = computed(() => {
  return !(
    props.tags.length === mutableTags.value.length &&
    props.tags
      .map((tag) => tag.name)
      .every((tag) => {
        return mutableTags.value.map((tag) => tag.name).includes(tag)
      })
  )
})

const addTagWithName = (name: string) => {
  if (name && !tagsHasTag(name)) {
    const existingTag = tagsStore.tags.find((tag) => tag.name === name)

    mutableTags.value.push({ name: name, id: existingTag ? existingTag.id : Date.now() })
    tagText.value = ''
    input.value?.focus()
  }
}
const addTagFromInput = () => {
  if (props.canCreate) {
    addTagWithName(tagText.value.trim())
  }
}

const deleteLastTag = (e: KeyboardEvent) => {
  if (!tagText.value) {
    e.preventDefault()
    mutableTags.value.pop()
  }
}

const deleteTagAtIndex = (i: number) => {
  mutableTags.value.splice(i, 1)

  input.value?.focus()
}

const onBlur = () => {
  if (tagsHaveChanged.value) {
    emit('change', unref(mutableTags))
  } else {
    emit('blur')
  }
}

const onEnter = () => {
  if (!autocompleteShowing.value) {
    input.value?.blur()
  }
}

nextTick(() => {
  input.value?.focus()
})
</script>

<style scoped></style>
